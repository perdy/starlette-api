{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83d\udd25 Fire up your API. Documentation : https://flama.perdy.io Flama \u00b6 Flama aims to bring a layer on top of Starlette to provide an easy to learn and fast to develop approach for building highly performant GraphQL and REST APIs. In the same way of Starlette is, Flama is a perfect option for developing asynchronous and production-ready services. Among other characteristics it provides the following: Generic classes for API resources that provides standard CRUD methods over SQLAlchemy tables. Schema system based on Marshmallow that allows to declare the inputs and outputs of endpoints and provides a reliable way of validate data against those schemas. Dependency Injection that ease the process of managing parameters needed in endpoints. Flama ASGI objects like Request , Response , Session and so on are defined as components and ready to be injected in your endpoints. Components as the base of the plugin ecosystem, allowing you to create custom or use those already defined in your endpoints, injected as parameters. Auto generated API schema using OpenAPI standard. It uses the schema system of your endpoints to extract all the necessary information to generate your API Schema. Auto generated docs providing a Swagger UI or ReDoc endpoint. Pagination automatically handled using multiple methods such as limit and offset, page numbers... Requirements \u00b6 Python 3.6+ Starlette 0.12.0+ Marshmallow 3.0.0+ Installation \u00b6 $ pip install flama Example \u00b6 from marshmallow import Schema , fields , validate from flama.applications import Flama # Data Schema class Puppy ( Schema ): id = fields . Integer () name = fields . String () age = fields . Integer ( validate = validate . Range ( min = 0 )) # Database puppies = [ { \"id\" : 1 , \"name\" : \"Canna\" , \"age\" : 6 }, { \"id\" : 2 , \"name\" : \"Sandy\" , \"age\" : 12 }, ] # Application app = Flama ( components = [], # Without custom components title = \"Foo\" , # API title version = \"0.1\" , # API version description = \"Bar\" , # API description schema = \"/schema/\" , # Path to expose OpenAPI schema docs = \"/docs/\" , # Path to expose Swagger UI docs redoc = \"/redoc/\" , # Path to expose ReDoc docs ) # Views @app . route ( \"/\" , methods = [ \"GET\" ]) def list_puppies ( name : str = None ) -> Puppy ( many = True ): \"\"\" description: List the puppies collection. There is an optional query parameter that specifies a name for filtering the collection based on it. responses: 200: description: List puppies. \"\"\" return [ puppy for puppy in puppies if puppy [ \"name\" ] == name ] @app . route ( \"/\" , methods = [ \"POST\" ]) def create_puppy ( puppy : Puppy ) -> Puppy : \"\"\" description: Create a new puppy using data validated from request body and add it to the collection. responses: 200: description: Puppy created successfully. \"\"\" puppies . append ( puppy ) return puppy Dependencies \u00b6 Following Starlette philosophy Flama reduce the number of hard dependencies to those that are used as the core: starlette - Flama is a layer on top of it. marshmallow - Flama data schemas and validation. It does not have any more hard dependencies, but some of them are necessaries to use some features: pyyaml - Required for API Schema and Docs auto generation. apispec - Required for API Schema and Docs auto generation. python-forge - Required for pagination. sqlalchemy - Required for Generic API resources. databases - Required for Generic API resources. You can install all of these with pip3 install flama[full] . Credits \u00b6 That library is heavily inspired by APIStar server in an attempt to bring a good amount of it essence to work with Starlette as the ASGI framework and Marshmallow as the schema system. Contributing \u00b6 This project is absolutely open to contributions so if you have a nice idea, create an issue to let the community discuss it.","title":"Home"},{"location":"#flama","text":"Flama aims to bring a layer on top of Starlette to provide an easy to learn and fast to develop approach for building highly performant GraphQL and REST APIs. In the same way of Starlette is, Flama is a perfect option for developing asynchronous and production-ready services. Among other characteristics it provides the following: Generic classes for API resources that provides standard CRUD methods over SQLAlchemy tables. Schema system based on Marshmallow that allows to declare the inputs and outputs of endpoints and provides a reliable way of validate data against those schemas. Dependency Injection that ease the process of managing parameters needed in endpoints. Flama ASGI objects like Request , Response , Session and so on are defined as components and ready to be injected in your endpoints. Components as the base of the plugin ecosystem, allowing you to create custom or use those already defined in your endpoints, injected as parameters. Auto generated API schema using OpenAPI standard. It uses the schema system of your endpoints to extract all the necessary information to generate your API Schema. Auto generated docs providing a Swagger UI or ReDoc endpoint. Pagination automatically handled using multiple methods such as limit and offset, page numbers...","title":"Flama"},{"location":"#requirements","text":"Python 3.6+ Starlette 0.12.0+ Marshmallow 3.0.0+","title":"Requirements"},{"location":"#installation","text":"$ pip install flama","title":"Installation"},{"location":"#example","text":"from marshmallow import Schema , fields , validate from flama.applications import Flama # Data Schema class Puppy ( Schema ): id = fields . Integer () name = fields . String () age = fields . Integer ( validate = validate . Range ( min = 0 )) # Database puppies = [ { \"id\" : 1 , \"name\" : \"Canna\" , \"age\" : 6 }, { \"id\" : 2 , \"name\" : \"Sandy\" , \"age\" : 12 }, ] # Application app = Flama ( components = [], # Without custom components title = \"Foo\" , # API title version = \"0.1\" , # API version description = \"Bar\" , # API description schema = \"/schema/\" , # Path to expose OpenAPI schema docs = \"/docs/\" , # Path to expose Swagger UI docs redoc = \"/redoc/\" , # Path to expose ReDoc docs ) # Views @app . route ( \"/\" , methods = [ \"GET\" ]) def list_puppies ( name : str = None ) -> Puppy ( many = True ): \"\"\" description: List the puppies collection. There is an optional query parameter that specifies a name for filtering the collection based on it. responses: 200: description: List puppies. \"\"\" return [ puppy for puppy in puppies if puppy [ \"name\" ] == name ] @app . route ( \"/\" , methods = [ \"POST\" ]) def create_puppy ( puppy : Puppy ) -> Puppy : \"\"\" description: Create a new puppy using data validated from request body and add it to the collection. responses: 200: description: Puppy created successfully. \"\"\" puppies . append ( puppy ) return puppy","title":"Example"},{"location":"#dependencies","text":"Following Starlette philosophy Flama reduce the number of hard dependencies to those that are used as the core: starlette - Flama is a layer on top of it. marshmallow - Flama data schemas and validation. It does not have any more hard dependencies, but some of them are necessaries to use some features: pyyaml - Required for API Schema and Docs auto generation. apispec - Required for API Schema and Docs auto generation. python-forge - Required for pagination. sqlalchemy - Required for Generic API resources. databases - Required for Generic API resources. You can install all of these with pip3 install flama[full] .","title":"Dependencies"},{"location":"#credits","text":"That library is heavily inspired by APIStar server in an attempt to bring a good amount of it essence to work with Starlette as the ASGI framework and Marshmallow as the schema system.","title":"Credits"},{"location":"#contributing","text":"This project is absolutely open to contributions so if you have a nice idea, create an issue to let the community discuss it.","title":"Contributing"},{"location":"api_schema/","text":"API Schemas \u00b6 Flama includes optional support for generating OpenAPI schemas , using apispec and pyyaml libraries. The Schema generator gathers all the API information needed directly from your code and infers the schema that represents your API based on OpenAPI standard. The schema will be also served under /schema/ route by default, but it is absolutety configurable. The Schema Generation \u00b6 Let's take a look at how the API schema is generated with an example that includes all the pieces involved in the process. The API used for this example will consist of a collection of puppies and some methods for handling it. Data Schemas \u00b6 First we define the data schemas that will be used to validate the inputs in our API. In our case we only need a single schema for defining a Puppy with a small set of attributes. from marshmallow import Schema , fields , validate class Puppy ( Schema ): id = fields . Integer () name = fields . String () age = fields . Integer ( validate = validate . Range ( min = 0 )) Routes \u00b6 Now that we have a proper input validation we can use those schemas to define the functions associated to each route in our API. In that case we are going to define a couple of endpoints, a first one for listing a collection and a second for creating a new resource in that collection. Our goal is to describe our API using a schema inferred directly from our codebase so our functions needs to be well documented using docstrings, that will be appended to our API schema following OpenAPI format. Regarding to our data schemas previously defined and used as annotations in our functions, it will be automatically inspected and will be part of the information of our endpoints. from . import schemas def list_puppies ( name : str = None ) -> schemas . Puppy ( many = True ): \"\"\" tags: - puppy summary: List puppies. description: List the puppies collection. There is an optional query parameter that specifies a name for filtering the collection based on it. responses: 200: description: List puppies. \"\"\" ... def create_puppy ( puppy : schemas . Puppy ) -> schemas . Puppy : \"\"\" tags: - puppy summary: Create a new puppy. description: Create a new puppy using data validated from request body and add it to the collection. responses: 200: description: Puppy created successfully. \"\"\" ... Application \u00b6 The last step is to define our main application and configure the highest level information of our schema, such as the title, version and a description, as well as the path use to serve it. from flama.applications import Flama from . import views app = Flama ( title = \"Puppy Register\" , # API title version = \"0.1\" , # API version description = \"A register of puppies\" , # API description schema = \"/schema/\" , # Path to expose OpenAPI schema ) app . add_route ( \"/\" , views . list_puppies , methods = [ \"GET\" ]) app . add_route ( \"/\" , views . create_puppy , methods = [ \"POST\" ]) Schema \u00b6 And here is the result schema of our example. components : schemas : APIError : properties : detail : description : Error detail title : detail type : string error : description : Exception or error type title : type type : string status_code : description : HTTP status code format : int32 title : status_code type : integer required : - detail - status_code type : object Puppy : properties : age : format : int32 minimum : 0 type : integer id : format : int32 type : integer name : type : string type : object info : description : A register of puppies title : Puppy Register version : '0.1' openapi : 3.0.0 paths : / : get : description : List the puppies collection. There is an optional query parameter that specifies a name for filtering the collection based on it. parameters : - in : query name : name required : false schema : default : null nullable : true type : string responses : '200' : content : application/json : schema : items : $ref : '#/components/schemas/Puppy' type : array description : List puppies. default : content : application/json : schema : $ref : '#/components/schemas/APIError' description : Unexpected error. summary : List puppies. tags : - puppy post : description : Create a new puppy using data validated from request body and add it to the collection. requestBody : content : application/json : schema : $ref : '#/components/schemas/Puppy' responses : '200' : content : application/json : schema : $ref : '#/components/schemas/Puppy' description : Puppy created successfully. default : content : application/json : schema : $ref : '#/components/schemas/APIError' description : Unexpected error. summary : Create a new puppy. tags : - puppy Disable Schema \u00b6 You can disable the schema generation by using None value for the schema argument. from flama.applications import Flama app = Flama ( title = \"Puppy Register\" , # API title version = \"0.1\" , # API version description = \"A register of puppies\" , # API description schema = None , # Disable api schema generation ) Swagger UI \u00b6 Swagger UI is a collection of HTML, Javascript, and CSS assets that dynamically generate beautiful documentation from a Swagger-compliant API. It's fully integrated with your application and can be served under an specific path simply configuring a single parameter. from flama.applications import Flama app = Flama ( title = \"Puppy Register\" , # API title version = \"0.1\" , # API version description = \"A register of puppies\" , # API description schema = \"/schema/\" , # Path to expose OpenAPI schema docs = \"/docs/\" , # Path to expose SwaggerUI application ) ReDoc \u00b6 ReDoc is an OpenAPI/Swagger-generated API Reference Documentation, a well-built application to serve your API docs based on your API schema. It's fully integrated with your application and can be served under an specific path simply configuring a single parameter. from flama.applications import Flama app = Flama ( title = \"Puppy Register\" , # API title version = \"0.1\" , # API version description = \"A register of puppies\" , # API description schema = \"/schema/\" , # Path to expose OpenAPI schema redoc = \"/redoc/\" , # Path to expose ReDoc application )","title":"API Schema"},{"location":"api_schema/#api-schemas","text":"Flama includes optional support for generating OpenAPI schemas , using apispec and pyyaml libraries. The Schema generator gathers all the API information needed directly from your code and infers the schema that represents your API based on OpenAPI standard. The schema will be also served under /schema/ route by default, but it is absolutety configurable.","title":"API Schemas"},{"location":"api_schema/#the-schema-generation","text":"Let's take a look at how the API schema is generated with an example that includes all the pieces involved in the process. The API used for this example will consist of a collection of puppies and some methods for handling it.","title":"The Schema Generation"},{"location":"api_schema/#data-schemas","text":"First we define the data schemas that will be used to validate the inputs in our API. In our case we only need a single schema for defining a Puppy with a small set of attributes. from marshmallow import Schema , fields , validate class Puppy ( Schema ): id = fields . Integer () name = fields . String () age = fields . Integer ( validate = validate . Range ( min = 0 ))","title":"Data Schemas"},{"location":"api_schema/#routes","text":"Now that we have a proper input validation we can use those schemas to define the functions associated to each route in our API. In that case we are going to define a couple of endpoints, a first one for listing a collection and a second for creating a new resource in that collection. Our goal is to describe our API using a schema inferred directly from our codebase so our functions needs to be well documented using docstrings, that will be appended to our API schema following OpenAPI format. Regarding to our data schemas previously defined and used as annotations in our functions, it will be automatically inspected and will be part of the information of our endpoints. from . import schemas def list_puppies ( name : str = None ) -> schemas . Puppy ( many = True ): \"\"\" tags: - puppy summary: List puppies. description: List the puppies collection. There is an optional query parameter that specifies a name for filtering the collection based on it. responses: 200: description: List puppies. \"\"\" ... def create_puppy ( puppy : schemas . Puppy ) -> schemas . Puppy : \"\"\" tags: - puppy summary: Create a new puppy. description: Create a new puppy using data validated from request body and add it to the collection. responses: 200: description: Puppy created successfully. \"\"\" ...","title":"Routes"},{"location":"api_schema/#application","text":"The last step is to define our main application and configure the highest level information of our schema, such as the title, version and a description, as well as the path use to serve it. from flama.applications import Flama from . import views app = Flama ( title = \"Puppy Register\" , # API title version = \"0.1\" , # API version description = \"A register of puppies\" , # API description schema = \"/schema/\" , # Path to expose OpenAPI schema ) app . add_route ( \"/\" , views . list_puppies , methods = [ \"GET\" ]) app . add_route ( \"/\" , views . create_puppy , methods = [ \"POST\" ])","title":"Application"},{"location":"api_schema/#schema","text":"And here is the result schema of our example. components : schemas : APIError : properties : detail : description : Error detail title : detail type : string error : description : Exception or error type title : type type : string status_code : description : HTTP status code format : int32 title : status_code type : integer required : - detail - status_code type : object Puppy : properties : age : format : int32 minimum : 0 type : integer id : format : int32 type : integer name : type : string type : object info : description : A register of puppies title : Puppy Register version : '0.1' openapi : 3.0.0 paths : / : get : description : List the puppies collection. There is an optional query parameter that specifies a name for filtering the collection based on it. parameters : - in : query name : name required : false schema : default : null nullable : true type : string responses : '200' : content : application/json : schema : items : $ref : '#/components/schemas/Puppy' type : array description : List puppies. default : content : application/json : schema : $ref : '#/components/schemas/APIError' description : Unexpected error. summary : List puppies. tags : - puppy post : description : Create a new puppy using data validated from request body and add it to the collection. requestBody : content : application/json : schema : $ref : '#/components/schemas/Puppy' responses : '200' : content : application/json : schema : $ref : '#/components/schemas/Puppy' description : Puppy created successfully. default : content : application/json : schema : $ref : '#/components/schemas/APIError' description : Unexpected error. summary : Create a new puppy. tags : - puppy","title":"Schema"},{"location":"api_schema/#disable-schema","text":"You can disable the schema generation by using None value for the schema argument. from flama.applications import Flama app = Flama ( title = \"Puppy Register\" , # API title version = \"0.1\" , # API version description = \"A register of puppies\" , # API description schema = None , # Disable api schema generation )","title":"Disable Schema"},{"location":"api_schema/#swagger-ui","text":"Swagger UI is a collection of HTML, Javascript, and CSS assets that dynamically generate beautiful documentation from a Swagger-compliant API. It's fully integrated with your application and can be served under an specific path simply configuring a single parameter. from flama.applications import Flama app = Flama ( title = \"Puppy Register\" , # API title version = \"0.1\" , # API version description = \"A register of puppies\" , # API description schema = \"/schema/\" , # Path to expose OpenAPI schema docs = \"/docs/\" , # Path to expose SwaggerUI application )","title":"Swagger UI"},{"location":"api_schema/#redoc","text":"ReDoc is an OpenAPI/Swagger-generated API Reference Documentation, a well-built application to serve your API docs based on your API schema. It's fully integrated with your application and can be served under an specific path simply configuring a single parameter. from flama.applications import Flama app = Flama ( title = \"Puppy Register\" , # API title version = \"0.1\" , # API version description = \"A register of puppies\" , # API description schema = \"/schema/\" , # Path to expose OpenAPI schema redoc = \"/redoc/\" , # Path to expose ReDoc application )","title":"ReDoc"},{"location":"applications/","text":"Applications \u00b6 Flama provides an application class that acts as an interface to interact with all functionality and configure some high level parameters. from flama import Flama def home (): \"\"\" tags: - hello-world summary: Hello world. description: Basic hello world endpoint. responses: 200: description: Hello world. \"\"\" return { \"hello\" : \"world\" } app = Flama ( components = [], # List of components used by this application debug = False , # Debug title = \"Puppy Register\" , # API title version = \"0.1\" , # API version description = \"A register of puppies\" , # API description schema = \"/schema/\" , # Path to expose OpenAPI schema docs = \"/docs/\" , # Path to expose SwaggerUI application redoc = \"/redoc/\" , # Path to expose ReDoc application ) app . add_route ( \"/\" , home , methods = [ \"GET\" ]) Flama application exposes the same interface than Starlette application but including own functionality. Adding Resources to the application \u00b6 You can use any of the following to add handled resources and its respective routes to the application: app.add_resource(path, resource) - Add a REST resource. The resource must be a Resource class. @app.resource(path) - Add a REST resource, decorator style. Dependency Injector \u00b6 The dependency injector is automatically created during application creation process. app.injector - Dependency injector. API Schema \u00b6 The schema is generated automatically gathering all routes from the application. app.schema - API schema. Note The API schema can only be generated if apispec is installed as a requirement.","title":"Applications"},{"location":"applications/#applications","text":"Flama provides an application class that acts as an interface to interact with all functionality and configure some high level parameters. from flama import Flama def home (): \"\"\" tags: - hello-world summary: Hello world. description: Basic hello world endpoint. responses: 200: description: Hello world. \"\"\" return { \"hello\" : \"world\" } app = Flama ( components = [], # List of components used by this application debug = False , # Debug title = \"Puppy Register\" , # API title version = \"0.1\" , # API version description = \"A register of puppies\" , # API description schema = \"/schema/\" , # Path to expose OpenAPI schema docs = \"/docs/\" , # Path to expose SwaggerUI application redoc = \"/redoc/\" , # Path to expose ReDoc application ) app . add_route ( \"/\" , home , methods = [ \"GET\" ]) Flama application exposes the same interface than Starlette application but including own functionality.","title":"Applications"},{"location":"applications/#adding-resources-to-the-application","text":"You can use any of the following to add handled resources and its respective routes to the application: app.add_resource(path, resource) - Add a REST resource. The resource must be a Resource class. @app.resource(path) - Add a REST resource, decorator style.","title":"Adding Resources to the application"},{"location":"applications/#dependency-injector","text":"The dependency injector is automatically created during application creation process. app.injector - Dependency injector.","title":"Dependency Injector"},{"location":"applications/#api-schema","text":"The schema is generated automatically gathering all routes from the application. app.schema - API schema. Note The API schema can only be generated if apispec is installed as a requirement.","title":"API Schema"},{"location":"components/","text":"TO DO","title":"Components"},{"location":"examples/","text":"Examples \u00b6 There are some complete examples to illustrate how each Flama functionality works. You can find them within the code repository . Hello World \u00b6 Source code A simple hello world example. Data Schema \u00b6 Source code Application that uses marshmallow data schemas for validating input and enforcing output. Pagination \u00b6 Source code Two different views that applies page-based pagination and limit-offset pagination. CRUD Resource \u00b6 Source code A RESTful resource that implements create , retrieve , update , delete and list methods. This example is particularly complete because it shows how to define a database connection and use hooks to effectively create/drop the connection with it during startup/shutdown. Also it explains how to define a data model and a data schema for its API resource.","title":"Examples"},{"location":"examples/#examples","text":"There are some complete examples to illustrate how each Flama functionality works. You can find them within the code repository .","title":"Examples"},{"location":"examples/#hello-world","text":"Source code A simple hello world example.","title":"Hello World"},{"location":"examples/#data-schema","text":"Source code Application that uses marshmallow data schemas for validating input and enforcing output.","title":"Data Schema"},{"location":"examples/#pagination","text":"Source code Two different views that applies page-based pagination and limit-offset pagination.","title":"Pagination"},{"location":"examples/#crud-resource","text":"Source code A RESTful resource that implements create , retrieve , update , delete and list methods. This example is particularly complete because it shows how to define a database connection and use hooks to effectively create/drop the connection with it during startup/shutdown. Also it explains how to define a data model and a data schema for its API resource.","title":"CRUD Resource"},{"location":"models/","text":"Models \u00b6 Flama relies on SQLAlchemy to define data models, specifically on SQLAlchemy Core . Here you can find a simple example of how to define a model, but you can find more complex examples in SQLAlchemy docs. import sqlalchemy as sa metadata = sa . MetaData () user = sa . Table ( \"users\" , metadata , sa . Column ( \"id\" , sa . Integer , primary_key = True ), sa . Column ( \"name\" , sa . String ), sa . Column ( \"age\" , sa . Integer ), ) You can also find useful some complete examples under these docs.","title":"Models"},{"location":"models/#models","text":"Flama relies on SQLAlchemy to define data models, specifically on SQLAlchemy Core . Here you can find a simple example of how to define a model, but you can find more complex examples in SQLAlchemy docs. import sqlalchemy as sa metadata = sa . MetaData () user = sa . Table ( \"users\" , metadata , sa . Column ( \"id\" , sa . Integer , primary_key = True ), sa . Column ( \"name\" , sa . String ), sa . Column ( \"age\" , sa . Integer ), ) You can also find useful some complete examples under these docs.","title":"Models"},{"location":"pagination/","text":"Pagination \u00b6 Flama provides a built-in mechanism to paginate API responses. This pagination comes with multiple flavors, such as page-based pagination and limit-offset pagination. Apply pagination to any API endpoint is as easy as apply a decorator to the view itself and Flama will handle the rest, including required parameters and wrapping the response into a paginated response. Page-based Pagination \u00b6 This pagination technique consists of specifying a page number and page size to define the exact window that should be returned. from flama import Flama , pagination app = Flama () @app . route ( \"/number/\" , methods = [ \"GET\" ]) @pagination . page_number def numbers ( ** kwargs ): return list ( range ( 100 )) Every paginated response automatically includes three new parameters: page: the number of the page (default 1 ). page_size: the number of elements for each page (default 10 ). count: a boolean to request the total number of elements as part of the response (default True ). The response schema is also modified to include some relevant metadata regarding of pagination status along with the response data itself. The modified responses consists of a data section with the expected data and a meta section with following attributes: page: the number of the page. page_size: the number of elements for each page. count: the total number of elements. Examples \u00b6 Some requests examples based on above endpoint. Default request \u00b6 GET https://flama.server/number/ { \"data\": [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], \"meta\": { \"page_size\": 10, \"count\": 100, \"page\": 1 } } Specific page \u00b6 GET https://flama.server/number/?page=2 { \"data\": [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ], \"meta\": { \"page_size\": 10, \"count\": 100, \"page\": 2 } } Different page size \u00b6 GET https://flama.server/number/?page_size=2 { \"data\": [ 0, 1 ], \"meta\": { \"page_size\": 2, \"count\": 100, \"page\": 1 } } Avoid counting elements \u00b6 GET https://flama.server/number/?count=false { \"data\": [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], \"meta\": { \"page_size\": 10, \"count\": null, \"page\": 1 } } Page-based Pagination \u00b6 This pagination technique consists of specifying a limit number of items to retrieve and the offset from the start of the collection to define the exact window that should be returned. import string from flama import Flama , pagination app = Flama () @app . route ( \"/alphabet/\" , methods = [ \"GET\" ]) @pagination . limit_offset def alphabet ( ** kwargs ): return list ( string . ascii_lowercase ) Every paginated response automatically includes three new parameters: limit: the maximum number of elements to retrieve (default 10 ). offset: the index of the starting element (default 0 ). count: a boolean to request the total number of elements as part of the response (default True ). The response schema is also modified to include some relevant metadata regarding of pagination status along with the response data itself. The modified responses consists of a data section with the expected data and a meta section with following attributes: limit: the maximum number of elements to retrieve. offset: the index of the starting element. count: the total number of elements. Examples \u00b6 Some requests examples based on above endpoint. Default request \u00b6 GET https://flama.server/alphabet/ { \"data\": [ \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\" ], \"meta\": { \"count\": 26, \"offset\": 0, \"limit\": 10 } } Using offset \u00b6 GET https://flama.server/alphabet/?offset=5 { \"data\": [ \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\" ], \"meta\": { \"count\": 26, \"offset\": 5, \"limit\": 10 } } Different limit \u00b6 GET https://flama.server/alphabet/?limit=2 { \"data\": [ \"a\", \"b\" ], \"meta\": { \"count\": 26, \"offset\": 0, \"limit\": 2 } } Avoid counting elements \u00b6 GET https://flama.server/alphabet/?count=false { \"data\": [ \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\" ], \"meta\": { \"count\": null, \"offset\": 0, \"limit\": 10 } }","title":"Pagination"},{"location":"pagination/#pagination","text":"Flama provides a built-in mechanism to paginate API responses. This pagination comes with multiple flavors, such as page-based pagination and limit-offset pagination. Apply pagination to any API endpoint is as easy as apply a decorator to the view itself and Flama will handle the rest, including required parameters and wrapping the response into a paginated response.","title":"Pagination"},{"location":"pagination/#page-based-pagination","text":"This pagination technique consists of specifying a page number and page size to define the exact window that should be returned. from flama import Flama , pagination app = Flama () @app . route ( \"/number/\" , methods = [ \"GET\" ]) @pagination . page_number def numbers ( ** kwargs ): return list ( range ( 100 )) Every paginated response automatically includes three new parameters: page: the number of the page (default 1 ). page_size: the number of elements for each page (default 10 ). count: a boolean to request the total number of elements as part of the response (default True ). The response schema is also modified to include some relevant metadata regarding of pagination status along with the response data itself. The modified responses consists of a data section with the expected data and a meta section with following attributes: page: the number of the page. page_size: the number of elements for each page. count: the total number of elements.","title":"Page-based Pagination"},{"location":"pagination/#examples","text":"Some requests examples based on above endpoint.","title":"Examples"},{"location":"pagination/#default-request","text":"GET https://flama.server/number/ { \"data\": [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], \"meta\": { \"page_size\": 10, \"count\": 100, \"page\": 1 } }","title":"Default request"},{"location":"pagination/#specific-page","text":"GET https://flama.server/number/?page=2 { \"data\": [ 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 ], \"meta\": { \"page_size\": 10, \"count\": 100, \"page\": 2 } }","title":"Specific page"},{"location":"pagination/#different-page-size","text":"GET https://flama.server/number/?page_size=2 { \"data\": [ 0, 1 ], \"meta\": { \"page_size\": 2, \"count\": 100, \"page\": 1 } }","title":"Different page size"},{"location":"pagination/#avoid-counting-elements","text":"GET https://flama.server/number/?count=false { \"data\": [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ], \"meta\": { \"page_size\": 10, \"count\": null, \"page\": 1 } }","title":"Avoid counting elements"},{"location":"pagination/#page-based-pagination_1","text":"This pagination technique consists of specifying a limit number of items to retrieve and the offset from the start of the collection to define the exact window that should be returned. import string from flama import Flama , pagination app = Flama () @app . route ( \"/alphabet/\" , methods = [ \"GET\" ]) @pagination . limit_offset def alphabet ( ** kwargs ): return list ( string . ascii_lowercase ) Every paginated response automatically includes three new parameters: limit: the maximum number of elements to retrieve (default 10 ). offset: the index of the starting element (default 0 ). count: a boolean to request the total number of elements as part of the response (default True ). The response schema is also modified to include some relevant metadata regarding of pagination status along with the response data itself. The modified responses consists of a data section with the expected data and a meta section with following attributes: limit: the maximum number of elements to retrieve. offset: the index of the starting element. count: the total number of elements.","title":"Page-based Pagination"},{"location":"pagination/#examples_1","text":"Some requests examples based on above endpoint.","title":"Examples"},{"location":"pagination/#default-request_1","text":"GET https://flama.server/alphabet/ { \"data\": [ \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\" ], \"meta\": { \"count\": 26, \"offset\": 0, \"limit\": 10 } }","title":"Default request"},{"location":"pagination/#using-offset","text":"GET https://flama.server/alphabet/?offset=5 { \"data\": [ \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\" ], \"meta\": { \"count\": 26, \"offset\": 5, \"limit\": 10 } }","title":"Using offset"},{"location":"pagination/#different-limit","text":"GET https://flama.server/alphabet/?limit=2 { \"data\": [ \"a\", \"b\" ], \"meta\": { \"count\": 26, \"offset\": 0, \"limit\": 2 } }","title":"Different limit"},{"location":"pagination/#avoid-counting-elements_1","text":"GET https://flama.server/alphabet/?count=false { \"data\": [ \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\" ], \"meta\": { \"count\": null, \"offset\": 0, \"limit\": 10 } }","title":"Avoid counting elements"},{"location":"resources/","text":"TO DO","title":"Resources"},{"location":"responses/","text":"TO DO","title":"Responses"},{"location":"templates/","text":"TO DO","title":"Templates"},{"location":"views/","text":"Views \u00b6 Flama can handle HTTP and Websocket requests through their endpoints system. Each endpoint consists of a function (a view), or a class with multiple methods (a set of views) where the business logic resides. Those pieces could be in charge of interacting with the data through models by creating, modifying or deleting them; or simply processing the request and building a proper response. HTTP \u00b6 Function Based Views \u00b6 HTTP function based views can be sync or async, so they can be defined as python sync or async functions and Flama will handle them properly. Following is a complete example of an application with a single function based view that composes a dummy response. from flama import Flama app = Flama () @app . route ( \"/foo/\" , methods = [ \"GET\" ]) def foo (): return { \"message\" : \"foo\" } Class Based Views \u00b6 Class based views have to define methods named as HTTP verbs, and they can be sync or async. Here is a complete example of an application with a class based endpoint including two views for handling GET and POST requests. from flama import Flama from flama.endpoints import HTTPEndpoint app = Flama () @app . route ( \"/foobar/\" , methods = [ \"GET\" , \"POST\" ]) class FooBarEndpoint ( HTTPEndpoint ): def get ( self ): return { \"message\" : \"foo\" } async def post ( self ): return { \"message\" : \"bar\" } Websocket \u00b6 Function Based Views \u00b6 A complete example of an application with a single function based view that relays to the websocket the data received from the request. from flama import Flama , websockets app = Flama () @app . websocket_route ( \"/foo/\" ) async def foo_websocket ( websocket : websockets . WebSocket , data : websockets . Data ): await websocket . send_bytes ( data ) Class Based Views \u00b6 Class based views have to define all the methods necessary to handle the communication of websocket protocol, those methods are: on_connect , on_disconnect and on_receive . It's required to override the last one, but the other two are already defined, so they can be used as they are. A complete example of an application with a class based endpoint including all websocket methods. from flama import Flama , websockets from flama.endpoints import WebSocketEndpoint app = Flama () @app . websocket_route ( \"/foo/\" ) class FooWebsocketEndpoint ( WebSocketEndpoint ): async def on_connect ( self , websocket : websockets . WebSocket ) -> None : await websocket . accept () async def on_disconnect ( self , websocket : websockets . WebSocket , websocket_code : websockets . Code ) -> None : await websocket . close ( websocket_code ) async def on_receive ( self , websocket : websockets . WebSocket , data : websockets . Data ) -> None : await websocket . send_bytes ( data )","title":"Views"},{"location":"views/#views","text":"Flama can handle HTTP and Websocket requests through their endpoints system. Each endpoint consists of a function (a view), or a class with multiple methods (a set of views) where the business logic resides. Those pieces could be in charge of interacting with the data through models by creating, modifying or deleting them; or simply processing the request and building a proper response.","title":"Views"},{"location":"views/#http","text":"","title":"HTTP"},{"location":"views/#function-based-views","text":"HTTP function based views can be sync or async, so they can be defined as python sync or async functions and Flama will handle them properly. Following is a complete example of an application with a single function based view that composes a dummy response. from flama import Flama app = Flama () @app . route ( \"/foo/\" , methods = [ \"GET\" ]) def foo (): return { \"message\" : \"foo\" }","title":"Function Based Views"},{"location":"views/#class-based-views","text":"Class based views have to define methods named as HTTP verbs, and they can be sync or async. Here is a complete example of an application with a class based endpoint including two views for handling GET and POST requests. from flama import Flama from flama.endpoints import HTTPEndpoint app = Flama () @app . route ( \"/foobar/\" , methods = [ \"GET\" , \"POST\" ]) class FooBarEndpoint ( HTTPEndpoint ): def get ( self ): return { \"message\" : \"foo\" } async def post ( self ): return { \"message\" : \"bar\" }","title":"Class Based Views"},{"location":"views/#websocket","text":"","title":"Websocket"},{"location":"views/#function-based-views_1","text":"A complete example of an application with a single function based view that relays to the websocket the data received from the request. from flama import Flama , websockets app = Flama () @app . websocket_route ( \"/foo/\" ) async def foo_websocket ( websocket : websockets . WebSocket , data : websockets . Data ): await websocket . send_bytes ( data )","title":"Function Based Views"},{"location":"views/#class-based-views_1","text":"Class based views have to define all the methods necessary to handle the communication of websocket protocol, those methods are: on_connect , on_disconnect and on_receive . It's required to override the last one, but the other two are already defined, so they can be used as they are. A complete example of an application with a class based endpoint including all websocket methods. from flama import Flama , websockets from flama.endpoints import WebSocketEndpoint app = Flama () @app . websocket_route ( \"/foo/\" ) class FooWebsocketEndpoint ( WebSocketEndpoint ): async def on_connect ( self , websocket : websockets . WebSocket ) -> None : await websocket . accept () async def on_disconnect ( self , websocket : websockets . WebSocket , websocket_code : websockets . Code ) -> None : await websocket . close ( websocket_code ) async def on_receive ( self , websocket : websockets . WebSocket , data : websockets . Data ) -> None : await websocket . send_bytes ( data )","title":"Class Based Views"}]}